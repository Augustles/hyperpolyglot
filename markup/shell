//a side-by-side reference sheet//

[#grammar-invocation grammar and invocation] | [#var-expr variables and expression] | [#arithmetic-logic arithmetic and logic] | [#strings strings] | [#regexes regexes] | [#dates-time dates and time] _
[#arrays arrays] | [#functions functions] | [#execution-control execution control] | [#exceptions exceptions] |  [#files files] | [#directories directories] | [#processes-environment processes and environment] _
[#libraries-namespaces libraries and namespaces] | [#objects objects] | [#reflection reflection]

||~ [[# general]]||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[[# version-used]][#version-used-note version used] _
@<&nbsp;>@||##gray|//dash; POSIX 2008//##||##gray|//2.1//##||##gray|//2.0//##||
||[[# version]][#version-note show version] _
@<&nbsp;>@|| ||$ osascript -e \ _
@<&nbsp;&nbsp;>@"AppleScript's version"||$host.version||
||||||||~ [[# grammar-invocation]][#grammar-invocation-note grammar and invocation]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[[# interpreter]][#interpreter-note interpreter] _
@<&nbsp;>@||$ dash foo.sh||$ osascript foo.scpt||@@PS>@@ .\foo.ps1 _
 _
@@DOS>@@ powershell -file foo.ps1||
||[[# repl]][#repl-note repl] _
@<&nbsp;>@||$ dash||##gray|//none//##||@@>@@ powershell||
||[[# exec-and-exit]][#exec-and-exit-note execute command and exit]||$ dash -c 'echo hi'||$ osascript -e 'say "hi"'||@@>@@ powershell -command 'write-host "hi"'||
||[[# stmt-separator]][#stmt-separator-note statement separator]||##gray|//pipelines separated by//## _
; & && @@||@@ _
 _
##gray|//lists of pipelines separated by newlines unless newline is preceded by a backslash or inside these characters://## _
"" '' @@``@@ ()||##gray|//newline; use ‚å•l (option lowercase L) to escape newline and continue statement on following line//##||; ##gray|//or newline; a newline can be escaped with a backtick://## @@`@@  ##gray|//newlines are permitted in double quotes and after a pipe://## | ||
||[[# word-separator]][#word-separator-note word separators]|| | & ; ( ) < > ##gray|//space tab//##|| || ||
||[[# block-delimiters]][#block-delimiters-note block delimiters]||{##gray|//...//##} _
(##gray|//...//##) _
do ##gray|//...//## done||##gray|//keyword//## ##gray|//...//## end ##gray|//keyword//## _
on ##gray|//funcName//## ##gray|//...//## end ##gray|//funcName//##||{ ##gray|//...//## }||
||[#expression-statement are expressions statements]||##gray|//no//##||##gray|//yes//##||##gray|//yes//##||
||[[# comment]][#comment-note end-of-line comment] _
@<&nbsp;>@|| # ##gray|//comment//##||@@--@@ ##gray|//comment//##||# ##gray|//comment//##||
||[[# multiline-comment]][#multiline-comment-note comment out multiple lines]||@@<<@@EOF _
##gray|//comment//## _
##gray|//another comment//## _
EOF||(* ##gray|//comment//## _
##gray|//another comment//## *)||<# ##gray|//comment//## _
##gray|//another comment//## #>||
||||||||~ [[# var-expr]][#var-expr-note variables and expressions]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[[# assignment]][#assignment-note assignment]||a=1 _
##gray|//whitespace next to//## = ##gray|//not permitted//##||set a to 1 _
copy 1 to a||$a = 1||
||[[# parallel-assignment]][#parallel-assignment-note parallel assignment] _
@<&nbsp;>@||##gray|//none//##||set {a,b} to {1,2}||$a, $b = 1, 2||
||[[# swap]][#swap-note swap]||tmp=$a _
a=$b _
b=$tmp||set {a,b} to {b,a}||$a, $b = $b, $a||
||[[# compound-assignment]][#compound-assignment-note compound assignment operators: arithmetic, string, bit]||##gray|//none//##||##gray|//none//##||+= -= *= /= %= _
+= *= _
##gray|//none//##||
||[[# incr-decr]][#incr-decr-note increment and decrement]||##gray|//none//##||##gray|//none//##||$x = 1 _
$x@@++@@ _
$x@@--@@||
||[[# var-decl]][#var-decl-note variable declaration] _
@<&nbsp;>@||##gray|//assignment//##, export, readonly||##gray|//assignment//##, local, global||##gray|//assignment//##||
||[[# identifiers-case-sensitive]][#identifiers-case-sensitive-note are identifiers case sensitive?]||##gray|//yes//##||##gray|//no//##||##gray|//no//##||
||[[# null]][#null-note null] _
@<&nbsp;>@||''||null||$null||
||[[# null-test]][#null-test-note null test] _
@<&nbsp;>@||[ -z $v ]||v = null||$v -eq $null||
||[[# undef-access]][#undef-access-note undefined variable access]||''||##gray|//error to access uninitialized variable//##||$null||
||[[# undef-test]][#undef-test-note undefined test]||f [ ${foo+1} ]; then _
@<&nbsp;&nbsp;>@echo "defined" _
else _
@<&nbsp;&nbsp;>@echo "undefined" _
fi||try _
@<&nbsp;&nbsp;>@set t to foo _
@<&nbsp;&nbsp;>@display dialog ("defined") _
on error _
@<&nbsp;&nbsp;>@display dialog ("undefined") _
end try||test-path variable:\foo||
||||||||~ [[# arithmetic-logic]][#arithmetic-logic-note arithmetic and logic]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[[# true-false]][#true-false-note true and false] _
@<&nbsp;>@||##gray|//status codes://## _
true false _
 _
##gray|//inside// [ ]:## _
1 ''||true false||$true $false||
||[[# falsehoods]][#falsehoods-note falsehoods]||##gray|//status codes: _
nonzero integers//## _
 _
##gray|//inside// [ ]:## _
''||##gray|//only integers convert to booleans://## _
false 0||0 0.0 "" ''||
||[[# logical-ops]][#logical-ops-note logical operators] _
@<&nbsp;>@||##gray|//status codes://## _
&& @@||@@ ! _
 _
##gray|//inside// [ ]:## _
-a -o ! ||and or not||-and -or -not||
||[[# conditional-expr]][#conditional-expr-note conditional expression] _
@<&nbsp;>@||$(( x>0 ? x : -x ))||##gray|//none//##||##gray|//none//##||
||[#relational-expr relational expression] _
@<&nbsp;>@||[ $a -gt 3 ]||a > 3||$a -gt 3||
||[#relational-operators relational operators] _
@<&nbsp;>@||##gray|//integers://## _
-eq -ne -gt -lt -ge -le _
 _
##gray|//strings://## _
@@=@@ != > < ##gray|//none//## ##gray|//none//##||@@=@@ /= > < >= <=||-eq -ne -gt -lt -ge -le||
||[#arithmetic-expr arithmetic expression] _
@<&nbsp;>@||$(( 1 + 3 ))||1 + 3||1 + 3||
||[#arithmetic-operators arithmetic operators] _
@<&nbsp;>@||+ - * ##gray|//none//## / % @@**@@||+ - * / div mod ^||+ - * / ##gray|//??//## % ##gray|//??//##||
||[#integer-division integer division] _
@<&nbsp;>@||$(( $a / $b ))||a div b||$rem = $null _
$quot = [Math]::DivRem($a, $b, [ref] $rem)||
||[[# int-div-zero]][#int-div-zero-note integer division by zero]||##gray|//writes "division by 0" error message; statement terminates with a 1 status//##|| ||##gray|//error: Attempted to divide by zero//##||
||[#float-division float division] _
@<&nbsp;>@||@@`@@echo " scale=5; $a / $b " | bc@@`@@||a / b||$a / $b||
||[[# float-div-zero]][#float-div-zero-note float division by zero]||##gray|//writes "division by 0" error message; statement terminates with a 1 status//##|| ||##gray|//evaluates to// Infinity //which is not a float literal//##||
||[[# power]][#power-note power] _
@<&nbsp;>@|| || ||[Math]::pow(2, 32)||
||[[# sqrt]][#sqrt-note sqrt] _
@<&nbsp;>@|| || ||[Math]::sqrt(2)||
||[#sqrt-negative-two sqrt -2] _
@<&nbsp;>@||##gray|//no sqrt//##|| ||##gray|//evaluates to// NaN //which is not a float literal//##||
||[#transcendental-func transcendental functions]||e l s c ##gray|//none//## ##gray|//none//## ##gray|//none//## a ##gray|//none//## _
##gray|//how to use://## _
@@`@@echo 'e(2)' | bc -l@@`@@|| ||[Math]::exp [Math]::log _
[Math]::sin [Math]::cos [Math]::tan _
[Math]::asin [Math]::acos [Math]::atan _
[Math]::atan2||
||[#float-truncation float truncation] _
##gray|//round towards zero, round to nearest integer, round down, round up//##||##gray|//none and no floats//##|| ||[Math]::truncate(3.14) _
[Math]::round(3.14) _
[Math]::floor(3.14) _
[Math]::ceiling(3.14)||
||[[# abs-val]][#abs-val-note absolute value] _
##gray|//and signum//##|| || ||[Math]::abs(-7) _
[Math]::sign(-7)||
||[#integer-overflow integer overflow] _
@<&nbsp;>@||##gray|//modular arithmetic//##|| ||##gray|//converts to float//##||
||[#float-overflow float overflow] _
@<&nbsp;>@||##gray|//no floats//##|| ||##gray|//evaluates to// Infinity //which is not a float literal//##||
||[#random random integer, uniform float]||echo $RANDOM ##gray|//15 bit integer//##||random number from 0 to 99 _
random number from 0.0 to 1.0||random 100 _
random 1.0||
||[#seed-random seed random numbers]||RANDOM=17 _
r=$RANDOM||set r to random number with seed 17||$r = random -setseed 17||
||[#bit-operators bit operators] _
@<&nbsp;>@||@<<< >> & | ^ ~>@||##gray|//none//##||##gray|//none//## ##gray|//none//## -band -bor -bxor -bnot _
 _
##gray|# powershell 3.0:## _
-lsl -lsr||
||||||||~ [[# strings]][#strings-note strings]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[#string-literal string literal]||'don'\''t say "no"' _
"don't say \"no\"" _
$'don\'t say "no"'||"don't say \"no\""||'don''t say "no"' _
"don't say @@`@@"no@@`@@""||
||[#string-literal-newline newline in literal]||##gray|//yes//##||##gray|//yes//##||##gray|//yes//##||
||[#barewords barewords]|| || || ||
||[#string-escapes escapes]||##gray|//in double quotes//## _
\\ \" _
##gray|//in//## $' ' ##gray|//quotes://## _
\a \b \e \f \n \r \t \v \\ \' \c##gray|//c//## \x##gray|//hh//## \##gray|//ooo//##||\\ \" _
\n \t \r _
##gray|//other backslash sequences cause syntax error//##||@@`@@' @@`@@" @@``@@ _
@@`@@0 @@`@@a @@`@@b @@`@@f @@`@@n @@`@@r @@`@@t @@`@@v _
##gray|//in other backtick sequences the backtick is ignored//##||
||[#variable-interpolation variable interpolation]||count=3 _
item=ball _
"$count ${item}s"||##gray|//none//##||$count = 3 _
$item = "ball" _
"$count $($item)s"||
||[#string-length length]||s="hello" _
${#s}||set s to "hello" _
count s||$s = "hello" _
$s.length||
||[#string-comparison string comparison]||[ $USER  = foo ] _
[ $USER != foo ]|| ||##gray|# case insensitive:## _
-eq -ne -gt -lt -ge -le _
 _
##gray|# case sensitive:## _
-ceq -cne -cgt -clt -cge -cle||
||[#index-substring index of substring]||##gray|//none//##||set s to "foo bar" _
offset of "bar" in s||##gray|//returns -1 if not found://## _
"foo bar".indexof("bar")||
||[#extract-substring extract substring]||s="foo bar" _
${s:4:3}||set s to "foo bar" _
characters 5 thru 7 of s as text||"foo bar".substring(4,3)||
||[#string-concatenation string concatenation]||c="hello, ""world"||set c to "hello, " & "world"||$c = "hello, " + "world"||
||[#string-replication string replication]|| || ||$hbar = "-" * 80||
||[#split split]||##gray|//none//##|| ||"foo,bar,baz" -split ","||
||[#join join]||##gray|//none//##|| ||@("foo","bar","baz") -join ","||
||[#sprintf sprintf]||@@`@@printf "tie: %s %d %f" "Spain" 13 3.7@@`@@|| ||$a = "Spain", 13, 3.7 _
"tie: {0} {1} {2}" -f $a||
||[#case case manipulation]||echo "hello" | tr [a-z] [A-Z] _
echo "HELLO" | tr [A-Z] [a-z] _
A=hello _
echo -n ${A:0:1} | tr [a-z] [A-Z]; echo -n ${A:1}|| ||"hello".toupper() _
"HELLO".tolower()||
||[#strip strip]||##gray|//none//##|| ||" hello ".trim()||
||[#pad pad on right, pad on left]||@@`@@printf "%-10s" "hello"@@`@@ _
@@`@@printf "%10s" "hello"@@`@@|| ||$s = "hello" _
$s + " " * (10 - $s.length) _
" " * (10 - $s.length) + $s||
||[#string-to-number string to number]||A="12" _
$(( 7 + $A )) _
 _
B=".037" _
@@`@@echo 73.9 + $B | bc@@`@@||set a to "12" _
7 + a as integer _
 _
set b = ".037" _
73.9 + b as real||7 + "12" _
 _
73.9 + ".037"||
||[#number-to-string number to string] _
@<&nbsp;>@||##gray|//all values are strings//##||7 as text & " items"||[convert]::tostring(7) + " items" _
 _
##gray|# or use variable interpolation##||
||||||||~ [[# regexes]][#regex-note regular expressions]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[[# regex-match]][#regex-match-note regex match]||s=hello _
rx='[a-z][a-z]*' _
if expr $s : $rx > /dev/null _
then _
@<&nbsp;&nbsp;>@##gray|//...//## _
fi|| ||if ("hello" -match "^[a-z][a-z]*$") { _
@<&nbsp;&nbsp;>@##gray|//...//## _
}||
||[[# single-subst]][#single-subst-note single substitution]||s='do re mi mi mi' _
s=$(echo $s | sed s/mi/ma/)|| || ||
||[[# global-subst]][#global-subst-note global substitution]||s='do re mi mi mi' _
s=$(echo $s | sed s/mi/ma/g)|| ||$s = "do re mi mi mi" _
$s = $s -replace "mi", "ma"||
||||||||~ [[# dates-time]][#dates-time-note dates and time]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||sleep||sleep 10||delay 10|| ||
||||||||~ [[# arrays]][#array-note arrays]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[#array-literal array literal]||nums=(1 2 3 4)||set nums to {1,2,3,4}||$nums = 1,2,3,4 _
$nums = @(1,2,3,4)||
||[#array-size array size]||${#nums[@]}||count nums _
length of nums||$nums.Length||
||[#array-lookup array lookup]||${nums[0]}||item 1 of nums||$nums[0]||
||[#array-modification array modification]||nums[1]=5||set item 1 of nums to 5||$nums[0] = 5||
||[#array-slice array slice]||${nums[@]:1:2}||items 2 thru 3 of nums||$nums[1..2]||
||[#array-concatenation concatenation]||a=(1 2 3) _
b=(4 5 6) _
c=(${a[@]} ${b[@]})||{1,2,3} & {4,5,6}||@(1,2,3) + @(4,5,6)||
||[#array-back manipulate back of array]|| ||set a to {6,7,8} _
set end of a to 9 _
##gray|//cannot remove elements from a list//##|| ||
||[#array-front manipulate front of array]|| ||set a to {6,7,8} _
set beginning of a to 5 _
##gray|//cannot remove elements from a list//##|| ||
||[#array-iteration array iteration]||for i in ${nums[@]} _
do echo $i _
done||repeat with i in nums _
@<&nbsp;&nbsp;>@display dialog(i as text) _
end repeat||foreach ($i in $nums) { _
@<&nbsp;&nbsp;>@write-host $i _
}||
||[#array-sort sort]|| ||##gray|//none//##||$a = 3,2,4,1 _
$b = $a | Sort-Object||
||[#array-reverse reverse]|| ||set a to {1,2,3} _
set b to reverse of a||$a = 1,2,3 _
[array]::reverse($a)||
||||||||~ [[# functions]][#functions-note functions]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[#function-definition function definition]||add() { echo $(( $1 + $2 )); } _
##gray|//or//## _
function add { echo $(( $1 + $2 )); }||on add(a, b) _
@<&nbsp;&nbsp;>@return a + b _
end add _
##gray|//or//## _
to add(a, b) _
@<&nbsp;&nbsp;>@return a + b _
end add||function add { _
@<&nbsp;&nbsp;>@param ($a, $b) _
@<&nbsp;&nbsp;>@$a + $b _
}||
||[#function-invocation function invocation]||add 1 2||add(1,2)||add 1 2||
||[#missing-argument missing argument value]||''||##gray|//error//##||$null||
||[#extra-arguments extra arguments]||##gray|//ignored//##||##gray|//ignored//##||##gray|//ignored//##||
||[#default-argument default argument value]||##gray|//none//##||##gray|//none//##||function add { _
@<&nbsp;&nbsp;>@param ($a=0, $b=0) _
@<&nbsp;&nbsp;>@$a + $b _
}||
||[#named-parameters named parameters]||##gray|//none//##||to displayNums from x to y _
@<&nbsp;&nbsp;>@set i to x _
@<&nbsp;&nbsp;>@repeat while i <= y _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@display dialog (i as text) _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@set i to i + 1 _
@<&nbsp;&nbsp;>@end repeat _
end displayNums _
displayNums to 5 from 1|| ||
||[#variable-arguments variable number of arguments]||##gray|//args in//## $1, $2, ... ##gray|//with number of args in//## $#||##gray|//none//##|| ||
||[#return-value return value]||return ##gray|//arg available in//## $? ##gray|//variable if a positive integer smaller than 256//##||##gray|//argument of// return //or value of last statement executed//##|| ||
||[#lambda-declaration lambda declaration]||##gray|//none//##||##gray|//none//##||$x = { write-host "foo" }||
||[#lambda-invocation lambda invocation]||##gray|//none//##||##gray|//none//##||& $x _
##gray|//or//## _
$x.invoke()||
||[#default-scope default scope]||##gray|//global//##||##gray|//local//##|| ||
||[#nested-functions nested function definition]||##gray|//visible outside containing function//##||##gray|//disallowed//##|| ||
||||||||~ [[# execution-control]][#execution-control-note execution control]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[#if if]||if [ $n -eq 0 ] _
then echo "no hits" _
elif [ $n -eq 1 ] _
then echo "1 hit" _
else echo $n " hits" _
fi||if n = 0 then _
@<&nbsp;&nbsp;>@display dialog ("0 hits") _
else if n = 1 then _
@<&nbsp;&nbsp;>@display dialog ("1 hit") _
else _
@<&nbsp;&nbsp;>@set s to n as text & " hits" _
@<&nbsp;&nbsp;>@display dialog (s) _
end if||if ($n -eq 0) { _
@<&nbsp;&nbsp;>@write-host "no hits" _
} elseif ($n -eq 1) { _
@<&nbsp;&nbsp;>@write-host "one hit" _
} else { _
@<&nbsp;&nbsp;>@write-host "$n hits" _
}||
||[#while while]||i=0 _
while [ $i -lt 10 ] _
do i=$(($i + 1)) _
echo $i _
done||set i to 0 _
repeat while i < 10 _
@<&nbsp;&nbsp;>@set i to i + 1 _
@<&nbsp;&nbsp;>@display dialog (i as text) _
end repeat||$i = 0 _
while ($i -lt 10) { _
@<&nbsp;&nbsp;>@write-host (++$i) _
}||
||[#break-continue break/continue]||break continue||exit ##gray|//none//##||break continue||
||[#for for]||for i in 1 2 3 _
do echo $i _
done||repeat with i from 1 to 3 _
@<&nbsp;&nbsp;>@display dialog (i as text) _
end repeat||for ($i=1; $i -le 3; $i++) { _
@<&nbsp;&nbsp;>@write-host $i _
}||
||||||||~ [[# exceptions]][#exceptions-note exceptions]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[#raise-exception raise exception]||##gray|//return nonzero status//##||error "bam!"||throw "bam!"||
||[#catch-exception catch exception]||trap 'echo "risky failed"' ERR _
risky||try _
@<&nbsp;&nbsp;>@error "bam!" _
on error msg _
@<&nbsp;&nbsp;>@display dialog ("error: " & msg) _
end try||try { _
@<&nbsp;&nbsp;>@throw "bam!" _
} _
catch { _
@<&nbsp;&nbsp;>@write-host "caught!" _
}||
||[#uncaught-exception uncaught exception behavior]||##gray|//stderr and continue//##||##gray|//display error and exits//##|| ||
||||||||~ [[# files]][#file-note files]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[#print-to-stdout print to standard out]||echo "hi world"||##gray|//popup window://## _
display dialog("hi world")||write-host "hi world"||
||[#standard-filehandles standard file handles]||/dev/stdin _
/dev/stdout _
/dev/stderr||##gray|//none//##|| ||
||[#read-line read line]||@@`@@head -1 /etc/passwd@@`@@||set f to POSIX file "/etc/passwd" _
set a to read f as text using delimiter linefeed _
item 1 of a|| ||
||[#read-file read file]||@@`@@cat /tmp/a@@`@@||set f to POSIX file "/tmp/a" _
set s to f as text|| ||
||[#write-file write to file]||echo "hello" > /tmp/a||set f to POSIX file "/tmp/a" _
open for access f with write permission _
write "hello" to f _
close access f|| ||
||[#append-file append to file]||echo "hello" @@>>@@ /tmp/a||set f to POSIX file "/tmp/a" _
open for access f with write permission _
write "hello" to f starting at eof _
close access f|| ||
||||||||~ [[# directories]][#directories-note directories]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||||||||~ [[# processes-environment]][#processes-environment-note processes and environment]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[#external-command external command]||ls||do shell script "ls"||dir||
||[#backticks backticks]||s=@@`@@ls@@`@@||set s to do shell script "ls"||$s=dir||
||[#command-line-args command line args]||$# _
$1 _
$2 _
##gray|//...//##||##gray|//must declare run handler://## _
on run argv _
@<&nbsp;&nbsp;>@length of argv _
@<&nbsp;&nbsp;>@item 1 of argv _
@<&nbsp;&nbsp;>@item 2 of argv _
@<&nbsp;&nbsp;>@##gray|//...//## _
end run|| ||
||[#speech speech]||##gray|//depends on OS//##||say "I'm a Mac"||$sp = new-object -comobject "SAPI.SpVoice" _
$sp.speak("I'm a PC")||
||[#environment-variable environment variable]||##gray|//shell variables are environment variables//## _
$HOME||system attribute "HOME"||$env:home||
||[#command-path command path]||which ping|| ||get-command ping||
||[#exit exit]||exit 0||##gray|//none//##||exit||
||[#set-signal-handler set signal handler]||function int_handler { _
@<&nbsp;&nbsp;>@echo "exiting..."; _
@<&nbsp;&nbsp;>@exit _
} _
 _
trap int_handler INT||##gray|//none//##|| ||
||[#start-background-job start job in background]||sleep 1000 &||##gray|//none//##|| ||
||[#suspend-job suspend current job]||##gray|//^Z//##||##gray|//none//##|| ||
||[#list-jobs list jobs]||jobs||##gray|//none//##|| ||
||[#background-suspended-job background suspended job]||bg %1||##gray|//none//##|| ||
||[#foreground-background-job bring background job into foreground]||fg %1||##gray|//none//##|| ||
||[#disown-job disown job]||disown %1||##gray|//none//##|| ||
||||||||~ [[# libraries-namespaces]][#libraries-namespaces-note libraries and namespaces]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[#library library]||$ cat foo.sh _
function add() { _
@<&nbsp;&nbsp;>@echo $(($1 + $2)); _
}||$ cat foo.applescript _
on showText(theText) _
@<&nbsp;&nbsp;>@display dialog (theText) _
end showText _
$ osascript -o foo.scpt foo.applescript|| ||
||[#import-library import library]||source foo.sh _
add 3 7||set f to "/path/to/foo.scpt" _
set foo to (load script POSIX file f) _
tell foo to showText("bar")|| ||
||[#library-path library path]||##gray|//none//##|| || ||
||[#library-path-env library path environment variable]||##gray|//none//##|| || ||
||[#namespace-declaration namespace declaration]||##gray|//none//##|| || ||
||[#namespace-separator namespace separator]||##gray|//none//##|| || ||
||||||||~ [[# objects]][#objects-note objects]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[#define-class define class]|| ||on makeInt(val) _
@<&nbsp;&nbsp;>@script theInt _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@property value : val _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@on addOne() _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@set value to value + 1 _
@<&nbsp;&nbsp;>@@<&nbsp;&nbsp;>@end addOne _
@<&nbsp;&nbsp;>@end script _
@<&nbsp;&nbsp;>@return theInt _
end makeInt|| ||
||[#create-object create object]|| ||set anInt to makeInt(7)|| ||
||[#getter-setter getter and setter]|| ||get value of anInt _
set value of anInt to 9|| ||
||[#invoke-method invoke method]|| ||tell anInt to addOne()|| ||
||||||||~ [[# reflection]][#reflection-note reflection]||
||~ ||~ [#posix posix shell]||~ [#applescript applescript]||~ [#powershell powershell]||
||[#class class]|| ||set s to "hello" _
display dialog class of s|| ||
||[#list-variables list defined variables]||printenv|| ||get-variable||
||~ ||~ ##EFEFEF|@@__________________________________________________________@@##||~ ##EFEFEF|@@__________________________________________________________@@##||~ ##EFEFEF|@@__________________________________________________________@@##||


[[# general-note]]
+ [#general General]

[[# version-used-note]]
++ [#version-used version used]

The version of the language used for verifying the examples in the reference sheet.

[[# version-note]]
++ [#version show version]

How to get the version.

[[# grammar-invocation-note]]
+ [#grammar-invocation Grammar and Invocation]

[[# interpreter-note]]
++ [#interpreter interpreter]

The customary name of the interpreter and how to invoke it.

**posix shell:**

On Unix, scripts are executing by passing the file containing the script to the interpreter as an argument:

[[code]]
$ dash ~/configure.sh
[[/code]]

If the executable bit is set, the file can be run directly:

[[code]]
$ ~/configure.sh	  
[[/code]]

To determine the name of the interpreter that will process the script, Unix will look for the presence of a shebang (#!) at the start of the file.  If the pathname to a command follows the shebang, it will be used to interpret the script.   If no shebang is present, the script will be interpreted with {{/bin/sh}} which is {{bash}} on Mac OS X and Cygwin and {{dash}} on Ubuntu.

Command line arguments which set the positional parameters $1, $2, and so on can be set upon invocation as follows:

[[code]]
$ dash ~/configure.sh arg1 arg2
$ ~/configure.sh arg1 arg2
[[/code]]

Arguments can also be put on the shebang line, but this is only useful for passing options to the shell.  If the file {{foo.sh}} contains

[[code]]
#!/bin/sh -x
[[/code]]

then invoking it as

[[code]]
./foo.sh
[[/code]]

is equivalent to

[[code]]
/bin/sh -x foo.sh
[[/code]]

Hardcoding a full path in a shebang is a common cause of portability problems because different systems may install the interpreter in different locations.  The {{env}} command avoids the problem by searching the PATH directories for the command:

[[code]]
#!/usr/bin/env lua
[[/code]]

**powershell:**

On Windows, a file is a PowerShell script if it has a {{.ps1}} suffix.  There is no need to mark the script as executable.  However, PowerShell is not configured to run scripts by default.  To change the configuration, start a PowerShell as an Administrator and run the following command:

[[code]]
set-executionpolicy remotesigned
[[/code]]

It is possible to invoke a PowerShell script by specifying the PowerShell interpreter as the command and the script as an argument, but the suffix of the file must still be {{ps1}}:

[[code]]
powershell -file .\test.ps1
[[/code]]

[[# repl-note]]
++ [#repl repl]

How to invoke the REPL.

**applescript:**

The closest to a AppleScript REPL is to launch the AppleScript Editor.  Snippets of AppleScript code can be entered into the upper pane.  When the //Run// button is clicked, the return value of the last statement executed will be displayed in the lower pane.

[[# exec-and-exit-note]]
++ [#exec-and-exit execute command and exit]

How to pass a single command to be executed as a command line argument.

[[# stmt-separator-note]]
++ [#stmt-separator statement separator]

How the parser determines the end of a statement.

**posix shell:**

A posix shell //simple command// consists of optional variable assignments, followed by a command and zero or more arguments and redirections.  The command can be an external command, user defined function, or built-in.

A posix shell //pipeline// is a sequence of one or more //simple commands// joined by pipes |.  The shell executes the commands in parallel and redirects the stdout of each command to the stdin of the following command.  The exit status is the status of the last command.

The //control operators// ; & && || are //pipeline// separators.  The semicolon ; enforces sequential execution.  The ampersand & executes in parallel.  The && executes to the first //pipeline// that returns a nonzero status.  The || executes to the first //pipeline// that returns a zero status.

A //list// is one or more //pipelines// joined by //control operators//.  A //list// can have a semicolon ; or ampersand & at the end.  A //list// is terminated by a newline.

A newline does not terminate a //list// when:

* inside single quotes '',  double quotes "", backticks @@``@@, or parens ()
* inside a block started by the keywords: for, select, case, if, while, until

A newline that would normally terminate a statement can be escaped with a backslash.

Multiple lists can be grouped inside parens ( ) or curly brackets { }.  When grouped inside parens, the lists are executed inside a subshell.  The curly brackets, but not the parens, must be separated from their contents by white space.    Also, within curly brackets, but not within parens, the last list must be terminated by a semicolon or newline.

[[# word-separator-note]]
++ [#word-separator word separators]

[[# block-delimiters-note]]
++ [#block-delimiters block delimiters]

How blocks are delimited.

**bash:**

Blocks can be delimited with {}, (), or the //do//,//done// keywords.

If a block is started with an open curly bracket {, then the block must be terminated with a line containing a close curly bracket by itself }.

If a block is delimited by (), then the commands in the block are executed in a subshell.

A block is delimited by //do// and //done// when using the execution control keywords //for//, //select//, //while//, and //until//.

The //then// and //else// keywords of an //if// statement start blocks which are terminated by a following //elif//, //else//, or //fi//.

The //function// and //if// keywords open blocks which are terminated by //end// keywords.  The //repeat// keyword opens a block which is terminated by //until//.

[[# comment-note]]
++ [#comment to end-of-line comment]

How to make the remainder of the line a comment.

**zsh:**

The # syntax for comments is only available in non-interactive shells unless the {{INTERACTIVE_COMMENTS}} option is set.  If an interactive shell encounters a # where a command is expected a {{command not found}} error will result.

[[# multiline-comment-note]]
++ [#multiline-comment multiline comment]

How to comment out multiple lines.

**bash:**

The method described is the syntax for a here document, which is a multiline string literal.

[[# var-expr-note]]
+ [#var-expr Variables and Expressions]

[[# assignment-note]]
++ [#assignment assignment]

How to assign a value to a variable.

**applescript:**

{{set}} and {{copy}} are not synonyms when operating on lists, records, or objects.  The {{set}} command makes the left variable an alias of the right variable: the two variables then refer to the same array, record, or object.  The {{copy}} command will put a copy of the array, record, or object contained in the left variable.

[[# parallel-assignment-note]]
++ [#parallel-assignment parallel assignment]

How to assign values to variables in parallel.

[[# swap-note]]
++ [#swap swap]

How to exchange the values held by two variables.

[[# compound-assignment-note]]
++ [#compound-assignment compound assignment operators: arithmetic, string, bit]

The compound assignment operators for arithmetic, string, and bit operations

**powershell**

Note that {{/=}} performs float division, even when both operands are integers.

When the left operand is a string, {{+=}} concatenates the right operand to the left operand.

When the left operand is a string and the right operand an integer, {{*=}} concatenates the left operand with itself //right operand// times.

[[# incr-decr-note]]
++ [#incr-decr increment and decrement]

The C-style increment and decrement operators which can be used in expressions.

[[# var-decl-note]]
++ [#var-decl variable declaration]

How to declare a variable.

**bash:**

The following three lines have identical behavior:

[[code]]
A="hello, world"
declare A="hello, world"
typeset A="hello, world"
[[/code]]

It is possible to make a read only variable.  Again there are three ways:

[[code]]
readonly A="can't change"
declare -r A="can't change"
typeset -r A="can't change"
[[/code]]

Variables are not exported to subprocesses unless declared to be exported:

[[code]]
export A="exported to subprocess"
declare -x A="exported to subprocess"
typeset -x A="exported to subprocess"
[[/code]]

Variables assigned on the same line as a command are not created, only exported to the subprocess that instantiates the command:

[[code]]
EDITOR=emacs svn commit
[[/code]]

By default variables defined inside functions are global.  They can be declared to be local:

[[code]]
function foo () {
  local b=17
  # echoes 17:
  echo $b
}
# echoes nothing:
echo $b
[[/code]]

**applescript:**

Variables can be declared as {{local}} or {{global}}. It is not possible to initialize a variable in a declaration.   Undeclared variables are {{local}}: in the example below, {{c}} and {{e}} are not visible outside the function {{foo}}:

[[code]]
on foo(a,b)
  local c
  global d
  set c to a+b
  set d to a+b
  set e to a+b
end foo
[[/code]]

[[# identifiers-case-sensitive-note]]
++ [#identifiers-case-sensitive are identifiers case sensitive?]

**applescript:**

In AppleScript, identifiers are case insensitive.  This holds for reserved keywords as well as user defined variable names.  The AppleScript Editor converts all keywords and identifiers in the source code to lower case when it is compiled.

**powershell:**

PowerShell identifiers are case insensitive.

[[# null-note]]
++ [#null null]

The null literal.

[[# null-test-note]]
++ [#null-test null test]

How to test if a value is null.

[[# undef-access-note]]
++ [#undef-access undefined variable access]

The value of an undefined variable, or the system behavior if there is no such value.

[[# undef-test-note]]
++ [#undef-test undefined test]

How to determine if a variable is undefined.

**posix shell:**

The expression ${##gray|//var//##+##gray|//val//##} is ##gray|//val//## if ##gray|//var//## is defined, otherwise it is the empty string ''.

The expression ${##gray|//var//##:+##gray|//val//##} is ##gray|//val//## if ##gray|//var//## is defined and not null, otherwise it is the empty string ''.

[[# arithmetic-logic-note]]
+ [#arithmetic-logic Arithmetic and Logic]

**posix shell:**

The POSIX shell provides at least three different environments for logical expressions, each with their own operators and values for true and false.

Logical expressions are usually encountered in the conditionals of {{if}}, {{elif}}, {{while}}, and {{until}}.  A command is expected as the conditional expression.  The command is executed, and a return value of zero is treated as true and nonzero as false.

||~ ||~ status codes||~ [ ]||~ $(( ))||
||where used||command||command||argument||
||true||true||##gray|//no canonical true value//##||1||
||false||false||''||0||
||falsehoods||##gray|//nonzero exit status//##||''||0||
||logical operators||&& @@||@@ !||-a -o !||&& @@||@@ !||
||grouping||{ }||\( \)||( )||
||string relational operators||##gray|//none//##|| = != \< \>||##gray|//none//##||
||arithmetic relational operators||##gray|//none//##||-eq -ne -lt -gt -le -ge||== != < > <= >=||
||arithmetic operators||##gray|//none//##||##gray|//none//##||+ - * / % **||
||bit operators||##gray|//none//##||##gray|//none//##||@@ << @@ @@ >> @@ & | ^ ~||

**posix shell: status codes:**

Logical expressions can be formed using status codes returned by commands.  The commands can be external, built-in, or user defined functions.  A status code of zero is used to indicate success, and for the purpose of logic zero is treated as true and all other status codes as false.

The && and @@||@@ operators are short circuit operators.  An exclamation point ! can be used to negate the status code of a command.   It is not necessary to separate && and @@||@@ from their operands with whitespace, but it is necessary to mark off a ! used as negation with whitespace.

**posix shell: test command:**

**posix shell: arithmetic expansion:**

[[# true-false-note]]
++ [#true-false true and false]

The literals for true and false.

[[# falsehoods-note]]
++ [#falsehoods falsehoods]

Values which are false in conditional expressions.


[[# logical-ops-note]]
++ [#logical-ops logical operators]

Logical and, or, and not.

**bash:**

&& || and ! are available inside [[ ]], (( )), and $(( )) expressions.  Inside [ ] expressions use -a, -o, and !.

[[# conditional-expr-note]]
++ [#conditional-expr conditional expression]

The syntax for a conditional expression.

[[# expression-statement]]
++ are expressions statements

Whether an expression can be used where a statement is expected.

[[# relational-expr]]
++ relational expressions

**bash:**

Bash has three types of relational expressions: [[ ]], [ ], and (( )).  For a description of [ ], read the [http://www.google.com/search?q=man+test man page for test].

(( )) evaluates its contents in the same manner as the arithmetic expansion $(( )).  If the result is zero, it returns 1 (false).  Otherwise it returns 0 (true).

[[ $a == ##gray|//pattern//## ]] and [[ $a != ##gray|//pattern//## ]] interpret * and ? on the right side as patterns.  Thus "hello" == "hell*" is true.  For numeric comparison, use [ $a -eq ##gray|//num//## ] or [ $a -ne ##gray|//num//## ].

[#bash-expressions Bash expressions] discusses the different types of bash expressions in more detail.


[[# relational-operators]]
++ relational operators

**bash:**

If == and =! have an unquoted string on the right, then * and ? within the string will be treated as wild cards for matching.

**applescript:**

Verbal synonyms for the relational operators are provided.  For {{=}} the synonyms are {{equals}}, {{is equal}}, {{equal to}}, and {{is equal to}}.

[[# string-to-number]]
++ convert from string

**bash:**

All values are strings.  The $(( )) operator will interpolate any variables and then evaluate the resulting string as an arithmetic expression composed of integers.  The variables are not limited to containing integers.  The following script outputs 10:

[[code]]
A=7+3
echo $(($A))
[[/code]]

To perform floating point arithmetic, bash must shell out to a floating point utility such as //bc//.

[[# number-to-string]]
++ convert to string


[[# arithmetic-expr]]
++ arithmetic expressions

How to evaluate an arithmetic expression.

**bash:**

Bash arithmetic is available within $(( )) and (( )).  The latter form evaluates the arithmetic expression and returns status 1 if the result zero, and 0 otherwise.

Bash only has integer arithmetic.  For floating point arithmetic, use the external commands //bc// or //dc//. 


[[# arithmetic-operators]]
++ arithmetic operators

The operators for addition, subtraction, multiplication, float division, integer division, modulus, and exponentiation.  Some languages provide a function //pow// instead of an operator for exponentiation.

**bash:**

arithmetic operators are available in $(( )) and (( )).

[[# integer-division]]
++ integer division

How to perform integer division.


[[# float-division]]
++ float division

How to perform floating point division, even if the operands might be integers.

**bash:**

The bash shell lacks built-in floating point arithmetic.  //bc// is an arbitrary precision calculator, and //scale// is the number of digits to the right of the decimal point.  If scale is not specified, it defaults to zero, which results in integer division.

It is also possible to use //dc//, which is a reverse polish notation arbitrary precision calculator:

[[code]]
`echo " 5 k $a $b / p " | dc`
[[/code]]

[[# arithmetic-functions]]
++ arithmetic functions

Functions for computing square root, natural exponent, natural logarithm, sine, cosine, tangent,  arcsine, arccosine, arctangent, and //atan2//.

The trigonometric functions are all in radians. //atan2// takes two arguments which are the x and y co-ordinates of a vector in the Cartesian plane.  It returns
the angle to the positive x-axis made by the vector.

**zsh:**

There is a zsh module which provides the standard transcendental math functions.  It is not installed by default on Mac OS X, the CentOS distribution of Linux, or Cygwin.  The module can be compiled into the zsh, or it can be in a shared library which is loaded with the command {{zmodload mathfunc}}.

[[# arithmetic-truncation]]
++ arithmetic truncation

[[# division-zero]]
++ division by zero

[[# integer-overflow]]
++ integer overflow

[[# float-overflow]]
++ float overflow

[[# sqrt-negative-two]]
++ sqrt -2

The result of taking the square root of -2.


[[# random]]
++ random integer, uniform float

The examples show how to generate a uniform random integer in the range from 0 to 99, inclusive; how to generate a uniform float in the range 0.0 to 1.0; how to generate a float from a standard normal distribution

**bash:**

$RANDOM evaluates to a random integer between 0 and 32767 inclusive.

**zsh:**

$RANDOM evaluates to a random integer between 0 and 32767 inclusive.

[[# seed-random]]
++ seed random numbers

**bash:**

Bash 3.2.48  seeds the random number at start up using the current time and the PID:

[[code]]
  /* Seed the random number generator. */
  sbrand (dollar_dollar_pid + shell_start_time);
[[/code]]

Here is the random number generation code:

[[code]]
/* A linear congruential random number generator based on the example
   one in the ANSI C standard.  This one isn't very good, but a more
   complicated one is overkill. */

/* Returns a pseudo-random number between 0 and 32767. */
static int
brand ()
{
  rseed = rseed * 1103515245 + 12345;
  return ((unsigned int)((rseed >> 16) & 32767));	/* was % 32768 */
}
[[/code]]

**zsh:**

Zsh {{rand}} and {{srand}} from the standard C library to generate random numbers.  It uses the current time at startup to seed the random number generator.  Here is the source code from zsh 4.3.9:

[[code]]
    gettimeofday(&shtimer, &dummy_tz);	/* init $SECONDS */
    srand((unsigned int)(shtimer.tv_sec + shtimer.tv_usec)); /* seed $RANDOM */
[[/code]]

**applescript:**

The initial seed is set to a value that varies each time AppleScript is started up.

If a repeatable sequence of random numbers is desired, the seed can be set to a specific value using the {{with seed}} parameter on the first call to {{random}}.  

**powershell:**

The initial seed is set to a value that varies each time PowerShell is started up.

If a repeatable sequence of random numbers is desired, the seed can be set to a specific value using the {{-setseed}} option on the first call to {{random}}.  

[[# bit-operators]]
++ bit operators

**bash:**

The bit operators are available in $(( )) and (( )).

[[# strings-note]]
+ [#strings Strings]

[[# string-literal]]
++ string literal

The syntax for a string literal and how to escape the delimiter.

[[# string-literal-newline]]
++ newline in literal

Whether a newline character sequence can be included in a string.

For all the languages described in this reference sheet a string literal is permitted to encompass multiple lines in the source code and the resulting string will contain the same number of lines.  

[[# string-escapes]]
++ escapes

Character escape sequences which can be used in string literals.

[[# variable-interpolation]]
++ variable interpolation

How to interpolate variables in a string.

**bash:**

A dollar sign {{$}} can be backslash escaped to prevent variable interpolation:

[[code]]
echo "the value of \$a is $a"
[[/code]]

**powershell:**

A dollar sign {{$}} can be backtick escaped to prevent variable interpolation:

[[code]]
write-host "the value of @@`@@$a is $a"
[[/code]]

[[# string-length]]
++ length

How to get the length of a string.

[[# string-comparison]]
++ string comparison

How to determine if two strings are equal or unequal.

[[# index-substring]]
++ index substring

How to find the index of the start of a substring in a string.

[[# extract-substring]]
++ extract substring

[[# string-concatenation]]
++ string concatenation

The string concatenation operator.

[[# split]]
++ split

How to split a string into an array of strings.

**powershell:**

When splitting a string into words, no delimiter need be specified and the string to be split can follow the {{-split}} operator:

[[code]]
-split "foo bar baz"
[[/code]]

[[# join]]
++ join

How to concatenate the elements of an array into a string with a separator.

[[# scan]]
++ scan

[[# sprintf]]
++ sprintf

How to create a string using a printf style format.

[[# case]]
++ case manipulation

[[# strip]]
++ strip

[[# pad]]
++ pad on right, pad on left

[[# regex-note]]
+ [#regexes Regular Expressions]

[[# regex-match-note]]
++ [#regex-match regex match]

How to test whether a regular expression matches a string.

**posix shell:**

The double square bracket operator {{[[ ]]}} is not part of the POSIX standard but it is a feature of {{bash}}, {{ksh}}, and {{zsh}}.  It supports a match test operator: 

[[code]]
if [[ "hello" =~ ^[a-z][a-z]*$ ]]; then
[[/code]]

[[# single-subst-note]]
++ [#single-subst single substitution]

How to replace the first occurrence of a pattern in a string.

**posix shell:**

The following parameter expansion is not part of the POSIX standard but provided by {{bash}}, {{ksh}}, and {{zsh}}:

[[code]]
str='do re mi mi mi'
echo ${str/mi/ma}
[[/code]]

[[# global-subst-note]]
++ [#global-subst global substitution]

How to replace all occurrences of a pattern in a string.

**posix shell:**

The following parameter expansion is not part of the POSIX standard but provided by {{bash}}, {{ksh}}, and {{zsh}}:

[[code]]
str='do re mi mi mi'
echo ${str//mi/ma}
[[/code]]

[[# dates-time-note]]
+ [#dates-time Dates and Time]

[[# array-note]]
+ [#arrays Arrays]


||~ ||~ bash||~ zsh||~ applescript||~ powershell||
||[#array-literal array]|| || ||list||array||
||[#dictionary-literal dictionary]|| || ||record|| ||


[[# array-literal]]
++ array literal

Array literal syntax.

[[# array-size]]
++ array size

How to get the number of elements in an array.

[[# array-lookup]]
++ array lookup

How to access a value in an array by index.



[[# array-slice]]
++ array slice

How to slice a subarray from an array.

[[# array-iteration]]
++ array iteration

[[# membership]]
++ membership

How to test for membership in an array.

[[# intersection]]
++ intersection

How to compute an intersection.

[[# union]]
++ union

[[# map]]
++ map

[[# filter]]
++ filter

[[# reduce]]
++ reduce

[[# universal-predicate]]
++ universal predicate

How to test whether a condition holds for all members of an array.  Always true for an empty array.

[[# existential-predicate]]
++ existential predicate

How to test whether an item in an array exists for which a condition holds.  Always false for an empty array.

[[# dictionary-literal]]
++ dictionary literal

[[# dictionary-size]]
++ dictionary size

[[# dictionary-lookup]]
++ dictionary lookup

[[# dictionary-iteration]]
++ dictionary iteration

[[# out-of-bounds]]
++ out of bounds behavior

[[# functions-note]]
+ [#functions Functions]

Python has both functions and methods.  Ruby only has methods: functions defined at the top level are in fact methods on a special main object.  Perl subroutines can be invoked with a function syntax or a method syntax.

[[# function-definition]]
++ function definition

**bash:**

A bash function definition can alternately be preceded by the keyword //function//, and when used, the parens following the function name are prohibited.

**zsh:**

A zsh function can be defined with the preceding keyword //function//, the trailing parens, or both.

**applescript:**

Functions are called //handlers// in AppleScript.

[[# function-invocation]]
++ function invocation

**bash:**

The syntax for invoking a function is the same as the syntax for invoking a command.  If a function is defined with the same name as a command in the search path, the function will be executed.  


[[# missing-argument]]
++ missing argument value

Value of an argument variable if a function is invoked with fewer arguments than are declared.

[[# extra-arguments]]
++ extra arguments

If a function is invoked with more arguments than are declared, how the function can access them.

[[# default-argument]]
++ default argument value

How to declare a default value for an argument.

[[# variable-arguments]]
++ variable number of arguments

How to write a function which accepts a variable number of argument.

[[# named-parameters]]
++ named parameters

How to write a function which uses named parameters.

**applescript:**

Named parameters are called //labeled parameters// in the AppleScript documentation.  The label must be one of the following prepositions:

> about, above, against, apart from, around, aside from, at, below, beneath, beside, between, by, for, from,
> instead of, into, on, onto, out of, over, since, thru/through, to, under

For readability the definite article {{the}} can be inserted in between the label and the argument in either the function definition or the invocation.  

To use other names for parameters, the {{given}} keyword can be used in conjunction with colon syntax:

[[code]]
on displayNums given startAt:x, endAt:y
  set i to x
  repeat while i <= y
    display dialog (i as text)
    set i to i + 1
  end repeat
end displayNums

displayNums given startAt:1, endAt:5
[[/code]]

When a {{given}} parameter takes a boolean value as an argument, the {{with}} or {{without}} keywords can be used when the handler is invoked.  Consider the following handler definition:

[[code]]
on foo given flagLabel:flag
  ...
end foo
[[/code]]

Here are two ways to invoke {{foo}} with {{flag}} set to true:

[[code]]
foo given flagLabel:true
foo with flagLabel
[[/code]]

Here are two ways to invoke {{foo}} with {{flag}} set to false:

[[code]]
foo given flagLabel:false
foo without flagLabel
[[/code]]

[[# return-value]]
++ return value

**bash:**

Bash functions can only return small integers via return.  However, a function can echo to stdout and the caller can invoke it with backticks to get a string value.

[[# lambda-declaration]]
++ lambda declaration

How to define a lambda function.

[[# lambda-invocation]]
++ lambda invocation

[[# default-scope]]
++ default scope

**bash:**

By default, bash and variables inside functions have global scope.

[[# execution-control-note]]
+ [#execution-control Execution Control]

[[# if]]
++ if

Some optional branching constructs:

**bash:**

[[code]]
case $a in (0) echo "no";; (1) echo "yes";; (2) echo "maybe";; (*) echo "error";; esac
[[/code]]


[[# while]]
++ while

**bash:**

Also has an //until// loop.

[[# break-continue]]
++ break/continue/redo

//break// exits a //for// or //while// loop immediately.  //continue// goes to the next iteration of the loop.  //redo// goes back to the beginning of the current iteration.

[[# for]]
++ for

**bash:**

A C-style for loop:

[[code]]
for ((i=0; i<10; i++ )); do echo $i; done
[[/code]]

**applescript:**

If a block of code needs to be executed a set number of times but no index variable is needed, AppleScript provides this alternate syntax:

[[code]]
repeat 3 times
	display dialog ("tut")
end repeat
[[/code]]


[[# exceptions-note]]
+ [#exceptions Exceptions]

[[# raise-exception]]
++ raise exception

How to raise an exception.

**applescript:**

It is possible to associate an error code with the error using the {{number}} label:

[[code]]
error "bam!" number 7
[[/code]]

If no error number is specified, then the value -2700 is used.

[[# catch-exception]]
++ catch exception

How to handle an exception.

**applescript:**

If a variable name is specified after {{on error}} the error message is stored in it.  There can only be one error clause and it catches all errors.  To perform conditional error handling, use the {{number}} label and provide a variable name after it.  The error code will be stored in that variable.

[[code]]
try
  error "bam!" number 7
on error msg number errorCode
  if errorCode = 7 then
    display dialog ("error: " & msg)
  else
    display dialog ("unknown error")
  end if
end try
[[/code]]

A {{try}} block can be closed by {{end error}} in addition to {{end try}}.

[[# uncaught-exception]]
++ uncaught exception behavior

System behavior if an exception goes uncaught.  Most interpreters print the exception message to stderr and exit with a nonzero status.

**bash:**

The bash interpreter writes a message to stderr whenever a command returns a nonzero status.  By default, the interpreter does not exit, but if this behavior is desired, then the following should be put at the top of the script:

[[code]]
trap exit ERR
[[/code]]


[[# wait-on-thread]]
++ wait on thread

[[# file-note]]
+ [#files Files]

[[# print-to-stdout]]
++ print to standard out

**bash:**

To prevent //echo// from appending a newline to the output, use

[[code]]
echo -n "hello"
[[/code]]

[[# standard-filehandles]]
++ standard filehandles

**applescript:**

AppleScript does not in general run with stdin and stdout filehandles.   When {{osascript}} is invoked as a shebang it is possible to read from stdin and write to stdout, however:

[[code]]
#!/usr/bin/env osascript 
set stdin to do shell script "cat" 
"Received from stdin: " & stdin 
[[/code]]

Here is how the above script would be invoked:

[[code]]
$ echo "foo" | ./stdin-example.sh 
Received from stdin: foo
[[/code]]


[[# read-line]]
++ read line

[[# read-file]]
++ read file

[[# write-file]]
++ write to file

[[# append-file]]
++ append to file


[[# directories-note]]
+ [#directories Directories]

[[# processes-environment-note]]
+ [#processes-environment Processes and Environment]

[[# external-command]]
++ external command

**bash:**

The syntax for calling an external command is the same as the syntax for invoking a function.  If a function is defined with the same name as an external command in the search path, the function is invoked.

[[# backticks]]
++ backticks

[[# command-line-args]]
++ command line args

[[# speech]]
++ speech

How to make the computer talk.

**bash, zsh:**

On Mac OSX the command {{say}} can also be executed from the bash or zsh prompt:

[[code]]
say "I'm a Mac"
[[/code]]

On Ubuntu Linux this command can be used:

[[code]]
espeak "I'm Unix"
[[/code]]

[[# environment-variable]]
++ environment variable

[[# command-path]]
++ command path

The directory containing a command.  Also indicates if the command is a built-in, alias, or function.  Shows the definition of aliases and functions.

**zsh:**

{{zsh}} has both {{which}} and {{which -a}}.  The latter shows all occurrences of a command in the search path.

[[# exit]]
++ exit

**bash:**

The exit status of a bash script is the return status of the last command executed, or the argument of //exit//.

[[# set-signal-handler]]
++ set signal handler

[[# libraries-namespaces-note]]
+ [#libraries-namespaces Libraries and Namespaces]

[[# library]]
++ library

What a library looks like.

[[# import-library]]
++ import library

[[# library-path]]
++ library path

[[# namespace-declaration]]
++ namespace declaration

[[# namespace-separator]]
++ namespace separator

[[# objects-note]]
+ [#objects Objects]

[[# define-class]]
++ define class

[[# create-object]]
++ create object

[[# constructor]]
++ constructor

[[# define-method]]
++ define method

[[# invoke-method]]
++ invoke method

[[# destructor]]
++ destructor


[[# default-method]]
++ default method

[[# inheritance]]
++ inheritance

[[# reflection-note]]
+ [#reflection Reflection]

[[# class]]
++ class

[[# posix]]
+ POSIX Shell

[http://pubs.opengroup.org/onlinepubs/9699919799/ POSIX 2008]
[http://linux.die.net/man/1/dash dash man page]
[http://linux.die.net/man/1/ksh ksh man page]
[http://linux.die.net/man/1/bash bash man Page]

On most modern systems if you invoke /bin/sh you get the bash shell. If your script might get run by the older Bourne shell (1977), here are the [http://www.gnu.org/software/bash/manual/bashref.html#Major-Differences-From-The-Bourne-Shell differences] to think about.

A function and a variable can have the same name. User defined variable identifiers cannot start with a digit. Variables are normally global, but can be made local to a function with the local keyword, which is useful for recursive functions.

The behavior of a shell script is dependent on its environment. All environment variables that existed when the shell process starts become variables in the script‚Äôs namespace. If the name of a command does not resolve to a shell built-in command or a function defined by the script, the shell searches the $PATH variable for an external command to run. The shell will expand ?, *, and ~ in words using the local file system.

The shell is good at launching external processes and redirecting their stdin and stdout to files or other processes with >, @@>>@@, ,@@ 2>>@@, or 2>&1.

[[# applescript]]
+ AppleScript

* [http://developer.apple.com/library/mac/#documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html AppleScript Language Guide]

* AppleScript Editor, osacompile, oascript
* getting dictionary for application, sending commands to an application
* I/O (display dialog, say, log)
* applications, windows, tabs
* open scripting architecture (OSA)

[[# powershell]]
+ PowerShell

* [http://msdn.microsoft.com/en-us/library/dd835506(VS.85).aspx PowerShell: Getting Started]